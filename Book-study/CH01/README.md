# Chapter01. 파이썬에서 러스트로 이동하기 위한 기본 준비

## Section01. 왜 Rust가 필요한가
01. 러스트는 어떤 언어인가?
- 모질라 재단이 지원하는 오픈 소스 프로그래밍 언어
- '안전성', '속도', '동시성'이라는 3대 요소를 개발 목표로 함.
- 시스템 프로그래밍 분야에서 주로 사용되는 C/C++ 언어를 대체할 수 있는 것을 목표로 함.

02. 러스트를 좋아하는 이유?
- 성능, 제어, 메모리 안전성, 동시성이 강한 점
- 관심 있는 기능을 제공해주는 점
- 개발 프로세스가 공개돼 있다는 점

03. 러스트의 특징
- 안전성: 보안 위협에 직결되는 메모리 관리와 Null 안전성 등 언어 자체의 안전성을 유지
- 속도: C/C++와 동등한 속도
- 동시성: 표준 라이브러리에도 스레드 안전(병렬 처리에서 메모리 접근 위반이 일어나지 않도록 만드는 것.)을 고려.

04. 러스트는 어렵다?
- 데이터 타입, 소유권 시스템 등 파이썬이나 그 외 다른 언어에서는 신경 쓰지 않아도 됐던 점까지 고려해가며 프로그램을 만들어야 한다.
- 소유권 시스템, 구조체/메서드, 트레잇/제너릭, 병렬 처리가 어려운 부분

## Section02. 파이썬과 러스트의 차이점
01. 파이썬 vs. 러스트
- 파이썬은 인터프리터 방식. 프로그램을 순차적으로 실행. 파이썬 -> 구문 분석 -> 중간 형태 -> 실행. 프로그램 실행까지가 빠르고, 유연성이 높다.
- 러스트는 컴파일러 방식. OS 네이티브 실행 바이너리로 변환한 뒤 실행. 러스트 -> 구문 분석 -> 중간 형태 -> 컴파일 -> 실행 파일 -> 실행. 사전에 type을 결정하고 실행 속도가 빠르다.

02. 인터프리터 방식 vs. 컴파일 방식
- 인터프리터 방식
    - 장점: 프로그램을 바로 실행할 수 있음. 가볍게 실행할 수 있음. 대화형 실행도 가능. 변수형 등이 동적으로 정해지기에 유연성 높은 처리가 가능
    - 단점: 프로그램 동작 속도는 컴파일러 방식보다 느림. 프로그램 실행 시 에러 발생하는 경우 많음.
    - 용도: 사무, 웹 서비스 개발 등
- 컴파일 방식
    - 장점: 프로그램 실행 속도가 빠름. 프로그램 실행 전 에러 발견 가능
    - 단점: 프로그램을 실행 파일로 변환하는 번거로움. 변수형 체크가 엄격
    - 용도: 시스템 기반 프로그램 등을 개발

03. 공통점
- 모던 언어
- 패키지 관리 시스템
    - 파이썬: PyPI라는 사이트에 많은 라이브러리가 등록. pip 명령을 이용하면 그 라이브러리의 최신 버전과 의존 관계 라이브러리까지 한 번에 다운 가능
    - 러스트: Cargo라는 패키지 관리 시스템 존재. 빌드 시스템 역할도 수행. cargo 명령을 이용 시, 의존 관계 라이브러리를 판별해 함께 다운 가능.
- 멀티 바이트 언어 처리
- 오픈 소스

04. 동적 타입 언어(파이썬) vs. 정적 타입 언어(러스트)
- 동적 타입 언어(파이썬): 변수의 값이나 함수의 인수, 반환값이 실행 중에 실제 값에 따라서 변함.
- 정적 타입 언어(러스트): 변수의 타입이 무엇인지 프로그램 실행 전에 명확히 알 수 있다. 타입 추론 기능도 존재.

05. 메모리 관리
- C/C++에서는 스스로 메모리를 확보하고 해제해야 한다.
- 파이썬: GC(Garbage Collector)라는 메모리 관리 메커니즘을 이용해 메모리 관리. 하지만 오버헤드가 크다. 참조 카운트라는 방식을 이용.
- 러스트: 소유권 시스템을 이용해 메모리 관리. 변수의 값이 유효한 범위가 명확히 정해져 있어 그 범위에서 벗어나면 메모리가 자동적으로 해제되는 구조.

## Section03. 러스트와 러스트 개발 환경 설치
01. VSCode(+ extensions) + Rust + Python

## Section04. 러스트 시작하기
01. 화면에 문자 표시하기
- 러스트는 만드시 main 함수를 만들어야 한다. 이 main 함수는 엔트리 포인트라고 하며, 프로그램 실행 시 가장 처음 실행된다.
- 화면 출력을 위한 매크로 사용(+ '!'가 붙는 것은 일반 함수가 아니라 매크로로 정의된 것, 매크로 사용 시 간결한 코드 작성 가능)
    ```
    println!("PRINT_TEXT");
    ```
- 문자열에 변수를 대입해서 출력. '{}'안에 value값이 들어가게 된다.
    ```
    println!("...STRING...{}...", VALUE);
    ```
- 러스트는 타입을 엄격하게 체크하는 언어이다. 따라서 정수는 딱 떨어지게, 실수는 .0을 붙여 인식시킬 수 있다.
    ```
    let car = 80; // 정수
    let btrain = 300.0; // 실수 
    ```

## Section05. 러스트와 파이썬으로 FizzBuzz 문제 풀기
01. for in 반복문. 변수를 사용하지 않고 반복시키려면 변수에 '_' 언더바를 넣는다.
    ```
    for 변수 in 시작값..종료값+1 {} // 시작값에서 종료값까지 반복
    for 변수 in 시작값..=종료값 {} // 시작값에서 종료값까지 반복
    ```

02. if else 조건문. 조건은 괄호로 감싸지 않는다.
    ```
    if 조건 {} else if 조건 {} else {}  // 조건에 같음을 나타내고 싶으면 == 동등연산자 사용
    ```

03. 러스트는 main 함수로부터 시작. 함수 정의하는 예약어 fn과 가장 먼저 실행되는 main.
    ```
    fn main() {}
    ```

04. 주석 처리.
    ```
    // 한줄 주석
    /*
        여러줄 주석
    */
    ```

05. 문장 끝에 세미콜론(;) 넣기

## Section06. 러스트와 파이썬으로 구구단 만들기
01. 문자열 길이 고정
    ```
    println!("{:3}", i) // i를 문자열 3으로 고정
    ```

02. print! vs. println!
- print!: 줄바꿈 출력하지 않음.
- println!: 줄바꿈 출력.

03. map사용.
- ex) map + collect를 이용해 문자열 벡터를 생성한 뒤 join으로 합치기
    ```
    let i = 1
    let s = (1..10)
            .map(|j| format!("{:3}", i*j))
            .collect::<Vec<String>>().join(",");
    println!("{}", s);
    // 1,  2,  3,  4,  5,  6,  7,  8,  9
    ```

## Section07. 변수 정의와 피보나치 수열
01. 변수 선언. 가급적이면 불변변수를 사용하고, 꼭 필요한 부분만 mut 속성을 넣어 선언한다.
    ```
    let 변수명 = 값;    // 불변, default immutable
    let mut 변수명 = 값; // 가변, mut 속성 추가
    ```

## Section08. 변수 타입과 거스름돈 조합 계산
01. 변수 타입.
- 정적 타입 언어이지만, 타입 추론 기능 덕분에 타입을 별도로 정의하지 않았다. 하지만, 함수를 정의하거나 구조체를 만들때는 정의해 주어야 한다. 계산 시, 계산하는 변수의 타입은 서로 일치해야 한다.
    ```
    let 변수명: 타입 = 값;
    ```
- 수치형
    - 부호가 있는 정수(음수, 0, 양수): i8, i16, i32, i64, i128, isize(사용중인 OS의 비트 길이)
    - 부호가 없는 정수(0, 양수): u8, u16, u32, u64, u128, usize(사용중인 OS의 비트 길이)
    - 부동 소수점(실수): f32, f64
    - 최댓값과 최솟값 확인하는 방법
    ```
    println!("{} ~ {}", [타입]::MIN, [타입]::MAX);
    ```

## Section09. 함수 정의와 시저 암호
01. 시저 암호
- 매우 단순한 암호로, 컴퓨터를 이용하지 않아도 쉽게 암호를 만들고 해독이 가능하다.

02. 문자와 문자열
- 문자: 1글자로 나타낼 수 있는 데이터 타입, 'A'(char)
- 문자열: 2글자 이상의 문자를 나타낼 수 있는 데이터 타입, "A"(&str / String)

03. let 변수명 = 변수 as 타입
- TYPE형태로 강제 타입 변환

04. String::new()
- 문자열 배열로 변수를 초기화 선언 시 사용

05. for ch in text.chars() {}
- text 문자열을 문자 하나씩 돌아가면서 처리

06. 함수 정의. 인수에 가변 길이를 넘겨줄 경우 &mut도 넣어주어야 한다.
    ```
    fn 함수명(인수 선언) -> 반환값 타입 {
        // 변수 선언 및 함ㅎ수의 동작 정의
    }
    ```

07. **클로저(Closure): 익명함수** -> 함수 정의보다 간편하게 만들 수 있다.(연습 필요~!!)
    ```
    let 이름 = |인수| 정의;
    ```

08. 삼항 연산자와 비슷하게 변수에 if를 사용해 값 선언
    ```
    let 변수 = if 조건 {참일 때} else {거짓일 때};
    ```

## Section10. 배열과 100개의 소수 계산
01. 지정한 길이의 배열 변수 만들기
- ex) [usize; 100] -> 100개의 usize 타입 배열
    ```
    let mut arr = [초깃값; 배열 길이];  // 배열 길이개의 초깃값으로 초기화된 배열.
    ```

02. 배열을 출력하는 경우 {:?} 사용
    ```
    println!("{:?}", 배열 변수);
    ```

03. 참조를 이용해 넘겨주기: 참조 '&'로 넘겨주고 역참조 '*'로 사용
    ```
    fn main() {set_value(&mut v);}
    fn set_value(arg: &mut u32) {*arg=100;}
    ```

04. for 문으로 배열의 요소 반복
    ```
    let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    for i in nums {....;}
    ```

05. 고정 배열이 아닌 배열의 요소 수를 변경하도록 할 수 있는 가변 배열
    ```
    let nums = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    ```