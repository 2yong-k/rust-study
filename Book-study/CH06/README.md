# Chapter06. 응용편 - 메모리 관리 및 다른 언어와의 연계

## Section01. 매크로 만들기
01. 러스트의 매크로
    - 매크로란? 프로그램 실행 전에 어떤 규칙에 따라 프로그램을 다시 작성하는 기능을 수행. 컴파일 시 실행되어 프로그램 자체를 변경.
    - 매크로 종류 2가지
        1. **선언적 매크로(declarative macro)**: 중복된 기술을 해야 하는 경우 간편하게 작성할 수 있도록 하기 위한 것.
        ex) printIn!, vec!, ...
        2. **절차적 매크로(procedural macro)**: 구조체에 자동으로 메서드 등을 추가하기 위한 역할.
        ex) #[derive(Clone, Copy)], ...

02. **선언적 매크로 만들기**
    - 선언적 매크로 만들기
    ```
    macro_rules! MACRO_NAME {
        (PATTERN_1) => { PROGRAM_1 };
        (PATTERN_2) => { PROGRAM_2 };
    }
    ```
    - 1개의 인수만 받는 매크로
    ```
    macro_rules! echo_num {
        ($num:expr) => {
            println!("{}", $num);
        };
    }
    ```
    - 2개 이상의 인수를 받는 매크로
    ```
    macro_rules! echo_nums {
        ( $( $num:expr ),* ) => {   // ,로 구분된 반복 나타냄 ;를 넣어도 된다.
            $(
                print!("{}, ", $num);
            )*
            println!("");
        }
    }
    ```
    - 다른 파일에서 이 파일을 읽어들였을 때, 해당 매크로를 사용할 수 있게 하는 선언
        => #[macro_export]

    - 매크로 정의에 사용할 수 있는 요소들
        1. expr: 표현식, 값
        2. item: 함수, 구조체, 상수, 모듈과 같은 아이템
        3. block: 블록 { ... }으로 감싼 부분
        4. stmt: 문장(쉼표가 없는 문장)
        5. pat: 패턴
        6. ty: 타입
        7. ident: 식별자(변수 이름 등)
        8. path: xxx::yyy::zzz와 같이 정의된 경로
        9. tt: 트리 구조(싱글 토큰)
        10. meta: 속성 내용. #[...] 또는 #![...]안의 내용
            - InnerAttribute : #![Attr] => 해당 Attribute가 선언된 범위 내에서 적용. 모듈 레벨의 설정이나 컴파일러 지시사항 지정. **전체**
            - OuterAttribute : #[Attr] => 해당 Attribute 이후에 오는 것(함수, 모듈, ...)에 적용. **개별**

    - 매크로 반복 패턴의 종류
        1. * : 0회 이상의 반복
        2. + : 1회 이상의 반복
        3. ? : 0회나 1회

03. 매크로를 이용해 BASIC의 for문 만들기 => macro_new => basic_for

04. 매크로를 이용해 HashMap을 간편하게 초기화하게 만들기 => macro_new => map_init
    - key와 value값을 동시에 받아 HashMap 초기화하기

05. 비만도 판정을 매크로로 정의하기 => macro_new => bmi_select

06. 매크로 재귀 호출 => macro_new => out_html

07. 실제 매크로가 만들어맨 코드 보기 - 매크로 전개
```
$ rustup update // cargo-expand의 버전과 컴파일러 버전이 안맞을 경우
$ cargo install cargo-expand
$ cargo expand  // 전체 소스 코드가 표시
$ cargo expand [요소 이름] // ex) main 넣을 시 메인 부분만
```

## Section02. 단방향 리스트로 메모리 관리 이해하기
01. 단방향 연결 리스트 구현
    - 저수준 처리를 통한 메모리 관리
    - 단방향 연결 리스트란? 신축성 있는 데이터 타입으로 데이터의 추가/삭제가 쉽다는 특징이 있다.
    - Box<T>를 이용한 구현.
        0. 이용하지 않으면 재귀 타입 구조체는 실제로 어느 정도 메모리를 할당해야 하는 지 알 수 없다.
        1. Box<T>는 T 타입 데이터를 힙 영역에 저장할 것을 요구하는 데이터 타입
        2. 힙 영역에 데이터가 확보되고, 스택 영역에는 힙 영역을 가리키는 고정 크기 포인터만 확보.

02. Null 표현
    - 가리키는 객체가 없는지와 다른 객체를 가리키는 값이 존재하는지.

03. 역참조와 참조
    0. ptr: (전제)변수 ptr은 &Box<Node> 타입
    1. *ptr: 역참조를 수행하므로 Box<Node> 타입을 얻음
    2. **ptr: Box<T>에서 값 T를 역참조하므로 Node 타입을 얻음
    3. &**ptr: Node에 대한 참조자를 얻으므로 &Node 타입을 얻음.

04. 단방향 연결리스트 => **slist**

## Section03. 메모리 참조 카운터
01. Box<T>를 이용한 단방향 연결 리스트의 단점
    - push 메서드는 데이터가 커질수록 효율이 떨어진다.
    - unshift 메서드는 괜찮다.

02. Rc<T>(Reference Counting) 타입으로 참조 카운팅 방식 메모리 관리 기능
    - Rc<T>는 힙 역역에 값 T를 저장하지만 참조 카운터 방식으로 1개의 객체에 복수의 소유자를 지정할 수 있다. 즉, 값을 공유할 수 있다.
    - **Rc<T>의 문제점**: 여러 소유자를 지정할 수 있지만 값을 변경할 수 없다.

03. RefCell<T> 타입으로 하나의 변수에 여러 소유자를 지정하고, 값을 변경해야 하는 경우에 사용
    - 값을 빌리는 메서드
        - borrow(): 값을 변경하지 않는 빌림
        - borrow_mut(): 값을 변경하는 빌림

04. Weak<T> 타입은 약한 참조를 나타내며, 소유권을 가지지 않는다. Rc는 반대로 강한 참조

05. **스마트 포인터 타입 특징**
    1. Box<T>: 공유X, 값변경O => 힙 영역에 T의 메모리 확보
    2. Rc<T>: 공유O, 값변경X => 힙 영역에 공유 가능한 T의 메모리 확보. 강한 참조
    3. Weak<T>: Rc에서 약한 참조가 필요한 경우.
    3. RefCell<T>: 공유X, 값변경O => 실행할 때 빌림 규칙을 강제
    4. Rc<RefCell<T>>: 공유O, 값변경O => 힙 영역에 공유 가능하고, 값 변경이 가능한 T의 메모리 확보
    5. Weak<RefCell<T>>: Rc에서 약한 참조가 필요할 경우
    6. 추가로
        - Arc<T>: Rc<T>와 마찬가지지만, 스레드 안전을 위해 고안된 타입
        - Mutex<T>: RefCell<T>와 마찬가지로 값 변경 가능
        - Arc<Mutex<T>>: Rc<RefCell<T>>와 마찬가지지만 스레드 안전을 추가한 타입.

06. 양방향 연결리스트 => **dlist**

## Section04. 파서 생성기로 미니 언어 만들기
01. 왜 언어를 직접 만드는가? 유지보수성이나 이용자 편의성을 위해
    - **구문 분석 표현 문법(PEG: Parsing Expression Grammar)**을 이용하여 언어를 만들고, **구문 분석 생성기(Parser Generator)**를 이용하여 문법을 정의해두고 그 정의를 바탕으로 컴파일러를 만들어내는 도구. ex) yacc

02. 러스트의 유명 구문 분석 생성기
    1. nom: 매크로로 구문 규칙을 지정할 수 있는 구문 분석 생성기. 바이너리 분석도 가능
    2. lalrpop: yacc, ANTLR, Memhir 같은 유명한 도구를 모방한 구문 분석 생성기
    3. combine: Haskell의 Parsec을 참고해 만든 LL 문법용 구문 분석 생성기
    4. peg: PEG 문법으로 구문 정의를 할 수 있는 구문 분석 생성기

03. PEG를 이용해보기
    - 형식 문법의 한 종류로 BNF와 비슷한 문법으로 구문 분석 생성기의 문법을 정의할 수 있는 표기법
    - Cargo.toml에 peg = "0.8" 넣기
    - parser에 문법 정의.
        ```
        rule RULE_NAME() -> RETURN_TYPE
            = SYNTAX_1 { ... }
            / SYNTAX_2 { ... }
            / SYNTAX_3 { ... }
        ```

04. 미니 언어 만들어보기
    1. node 모듈: 구문 요소 정의
    2. parser 모듈: peg 크레이트를 이용해 구문 해석 수행
    3. runner 모듈: 구문 분석 결과를 바탕으로 프로그램을 실행
    4. main: 만든 언어로 만든 프로그램을 실행할 메인 함수와 테스트 함수 존재.

## Section05. 