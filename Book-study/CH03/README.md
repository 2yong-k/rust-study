# Chapter03. 소유권 시스템과 데이터 타입

## Section01. 최초의 난관, 소유권 시스템
01. 소유권(ownership) 시스템이란?
- 러스트의 가장 유니크한 특성
- 가비지 콜텍터 없이 메모리 안정성을 보장
- 확보한 메모리를 사용이 끝난 시점(블록을 벗어나는 시점)에 자동으로 파기하는 기능
- 메모리의 유효성을 검증하는 컴파일러의 기능: Borrow checker(빌림 확인)

02. 소유권 시스템의 장점
- C/C++ 언어와 같이 수동으로 메모리 확보와 해제를 하지 않아, 메모리 관련 오류(이중 해제, 미해제)가 발생하지 않는다.
- 댕글링 포인터(Dangling pointer, 해제된 메모리를 가리키는 포인터)에 접근이 불가능하므로, 거기서 발생하는 보안 문제가 발생하지 않는다.
- 가비지 컬렉터(Garbage collector, GC)가 없이 소유권 시스템을 통해 메모리 관리를 하기 때문에 안전하며 효율적으로 고속 프로그램을 만들 수 있다.

03. 소유권 시스템의 단점
- 다른 언어의 일반적인 개념이 아닌 소유권 시스템을 제대로 이해하지 않으면, 어려움이 따를 수 있다.

04. 메모리 관리 == 소유권 ?
- 변수를 대입하거나 함수를 호출해 소유권을 가질 수 있지만, 그 소유권이 한번 이동하면 원래의 변수는 다시 이용할 수 없다.

05. 소유권의 3대 기본 원칙
- 원칙1: 값에는 '소유권'이 있으며 변수는 값의 '소유자'가 된다.
- 원칙2: 소유권은 이동할 수 있지만, '소유자'는 1개(1개의 변수)뿐이다.
- 원칙3: '소유자'가 유효한 범위(Scope)를 벗어나면 값은 파기된다.

06. 소유권 시스템을 적용받지 않는 타입
- 정수, 부동 소수점 등의 숫자 타입이나 Boolean 타입 등은 소유권 시스템이 동작하지 않는다. -> 소유권이 이동하는 것이 아니라, 복사가 된다.

07. 힙 영역과 스택 영역
- 힙(HEAP) 영역 메모리: 임의의 순서로 메모리를 확보하거나 해제할 수 있다. 원할 때 필요한 만큼 메모리 확보가 가능하다.
- 스택(STACK) 영역 메모리: 순차적(마지막에 있는 메모리부터)으로만 메모리를 확보하고 해제할 수 있다.
- 메모리 크기가 이미 정해진 데이터는 스택 영역에 저장할 수 있지만, 크기가 변하는 가변 데이터는 힙 영역에 저장해야 된다.
    - 따라서 문자열이나 구조체와 같이 크기가 변한는 데이터는 힙 영역에 저장된다.
    - 반면 숫자 데이터 등의 기본 타입 데이터는 스택 영역에 저장되므로 데이터 복제가 빠르고 쉽다. 이로 인해 소유권 관리를 하지 않고 값을 복사하는 것.

08. 기본 타입 값 외에도 소유권 시스템을 적용받지 않는 값. **RC<T>, Arc<T>**
- 참조 카운터를 사용해 메모리 관리를 할 수 있다.

09. clone 사용 시 소유권 이동 없이, 데이터를 복제하여 사용할 수 있다.

## Section02. 빌림과 참조
01. 빌림이란?
- 값의 소유권을 일시적으로 가져오고 사용이 끝나면 반납하는 형식.

02. 함수 호출로 소유권이 이동할 수 있음. return을 이용해 mut한 변수에 다시 값을 돌려준다면 다시 소유권 이전이 일어날 수 있다.

03. 참조와 빌림 - 함수 호출을 했을 때 소유권을 이동하지 않는 방법
- 참조 값만 전달하여 소유권을 유지한다.
    - 전해주는 참조 값은 &value
    - 함수의 인자에는 args : &String
    - 위와 같이 사용하면 참조 값만 전달이 가능하다.

04. 참조자를 반환하는 함수
- 함수에서 실제 값을 반환할 시, 이 값을 받아 사용이 가능하다.

05. 가변 참조자를 인수로 사용하기
- 함수의 인수로 지정한 값의 참조자를 변경한다.
    - 전해주는 참조 값은 &mut value
    - 함수의 인자에는 args: &mut String
    - 위와 같이 사용하면 바뀐 참조자를 얻을 수 있다.

06. 함수를 호출해서 인수를 변경하는 방법
- 함수의 인수로 지정된 값을 이용하여 원래 값을 변경한다.
    - 전해주는 참조 값은 &mut value
    - 함수의 인자에는 args: &mut String
    - 함수의 내부에서는 바꾸고자 할 때, *args = String::from("~~~~"); 으로 변경이 가능하다.

07. 참조 호출 vs. 값 호출
- **참조 호출**: 참조자(변수를 가리키는 주소)가 전달. 함수 안에서 인수의 내용을 변경하면 함수를 호출한 곳의 값도 바뀐다.
- **값 호출**: 값이 복사되어 함수에 전달. 함수 안에서 인수의 내용이 어떤 식으로 변경되더라도 호출한 곳에서는 아무런 영향이 없다.

## Section03. 러스트의 튜플, 배열, 슬라이스
01. 튜플이란?
- 서로 다른 데이터 타입을 하나로 모을 수 있다.
- 인덱스로 접근이 가능하다.
- 튜플 정의
    ```
    let VAR = (value1, value2, value3. ...);
    println!("{}, {}, {}", VAR.0, VAR.1, VAR.2);
    ```

02. 배열?
- 모든 요소들이 타입이 동일.
- 배열 정의
    ```
    let VARs:[i32;5] = [i32_1, i32_2, i32_3, i32_4, i32_5];
    println!("{:?}", VARs);
    println!("len={}", VARs.len());
    ```

03. 슬라이스?
- 배열이나 벡터, 문자열 같은 데이터 타입의 요소 중 일부를 참조하기 위한 것.
- 기본적으로 참조자이므로 소유권 개념은 없다.

## Section04. 러스트의 구조체
01. 구조체란?
- 사용자들이 연관된 여러 값들을 묶어서 의미있는 데이터 단위를 정의.

02. 구조체 정의하기
- 구조체를 만들면 그 구조체는 자체 데이터 타입으로 취급
    ```
    struct STRUCT_NAME {
        FIELD 1: TYPE 1,
        FIELD 2: TYPE 2,
        FIELD 3: TYPE 3,
        ...
        FIELD A: TYPE A
    }
    ```

03. 구조체와 변수의 명명 규칙
- 카멜 방식: CamelCase - 구조체, 타입, 열거형, 타입 매개변수
- 스네이크 방식(소문자): snake_case - 크레이트, 모듈, 함수, 메서드, 지역 변수
- 스네이크 방식(대문자): SNAKE_CASE - 상수, 고정 변수